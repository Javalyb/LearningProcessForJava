JVM:
![img_1.png](img_1.png)  

参考文档:
1.https://live.csdn.net/room/weixin_48013460/4YvQjPxO?utm_medium=distribute.pc_video_live.none-task-liveroom-csdn&depth_1-utm_source=distribute.pc_video_live.none-task-liveroom-csdn&spm=1016.2107.3001.4252

JVM内存模型(运行区数据区):
数据区:
    1.堆(动态数据区): 类的实例对象，数组，字符串常量池，静态变量
    2.方法区(静态数据区):
        类型信息
            类(修饰符，继承信息，实现信息)，接口，注解，枚举
        方法信息(包括构造方法)
            名字，修饰符，返回值，入参
        域(字段)信息
            修饰符，类型
        运行时常量池
        JIT(即时编译器)编译后的热点代码
运算区:
    3.虚拟机栈(以栈桢的方式存储): 方法调用的顺序和执行过程，包括方法中的局部变量和运行时常量;
        栈桢:
            局部变量表
            操作数栈
            返回地址
            动态链接
    4.本地方法栈: 和虚拟机栈类似，管理的是本地方法;
    5.程序计数器: 保存当前线程执行字节码的行号;

对象的创建过程:
    
类加载器: 
Bootstrap加载器: 加载虚拟机自身运行所需的class;
ExtClassloader: 加载执行目录下一个特殊的class;
AppClassLoader: 加载classpath路径下的class，以及main函数所在类的class文件;

类加载器双亲委派:

类加载过程: 解析可能在初始化之后(运行时绑定);  
    ![img_2.png](img_2.png)    
    1.加载: 通过类加载器加载字节码进虚拟机;
    2.验证: 确保被加载的类的正确性;
    3.准备: 为类的静态变量分配内存，并将其赋为默认值;
    4.解析: 将常量池中的符号引用替换为直接引用(内存地址)的过程;
    5.初始化: 为类的静态变量赋初始值(只有在第一次调用类的静态引用时才初始化);
    6.使用: 初始化后才能使用;
    7.卸载: 程序正常结束，OOM，System.exit(0)，异常;

垃圾回收(GC):

堆的分代模型:  
![img.png](img.png)  
GC算法:
垃圾回收器:

执行引擎:
    解释器: 解析字节码为机器码;
    即时编译器: 将热点代码提前编译成机器码;
    垃圾回收器 



